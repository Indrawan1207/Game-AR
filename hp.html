<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Finger Explosion: Game AI yang bikin jari lo jadi senjata!</title>
  <link rel="icon" type="image/png" href="assets/fav.png">

  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">

  <style>
    :root { --p1-color: #00d2ff; --p2-color: #ff007f; --bg-glass: rgba(10, 10, 10, 0.85); }
    html, body { margin:0; padding:0; width:100%; height:100%; background:#000; color:#fff; font-family:'Orbitron', sans-serif; overflow:hidden; touch-action:none; }
    /* Canvas tetap mirror untuk efek “selfie”, tapi mapping akan disesuaikan di JS */
    canvas { width:100vw; height:100vh; object-fit:cover; transform:scaleX(-1); }

    /* HUD responsive */
    .hud { position:absolute; top: max(12px, env(safe-area-inset-top)); left:0; width:100%; display:flex; justify-content:space-around; align-items:flex-start;
           pointer-events:none; z-index:10; transition:0.5s; padding: 0 10px; box-sizing:border-box; gap:8px;}
    .score-box { padding: 10px 18px; border-radius: 18px; background: var(--bg-glass); border: 2px solid #fff; text-align:center; min-width: 120px; }
    .p1-ui { border-color: var(--p1-color); box-shadow: 0 0 18px color-mix(in srgb, var(--p1-color) 80%, transparent); color: var(--p1-color); }
    .p2-ui { border-color: var(--p2-color); box-shadow: 0 0 18px color-mix(in srgb, var(--p2-color) 80%, transparent); color: var(--p2-color); }

    .overlay { position:fixed; inset:0; background: radial-gradient(circle, #111 0%, #000 100%); z-index:100; display:flex; flex-direction:column; justify-content:center; align-items:center; transition:0.5s; padding: 18px; box-sizing:border-box;}
    .glass-panel { padding: 28px; border-radius: 24px; border: 1px solid rgba(255,255,255,0.1); text-align:center; background: rgba(0,0,0,0.55); backdrop-filter: blur(8px); width: min(560px, 94vw); }

    #winner-display { display:none; background: rgba(0,0,0,0.25); backdrop-filter: blur(2px); z-index:100; }
    #winner-display .glass-panel { background: rgba(0,0,0,0.75); border: 3px solid #fff; box-shadow: 0 0 50px rgba(0,0,0,1); }

    h1 { font-size: clamp(1.8rem, 4.2vw, 3rem); margin:0 0 14px; letter-spacing: 4px; text-shadow: 0 0 20px #fff; }
    p { margin: 0 0 10px; }

    input[type="number"] { background:#000; border:2px solid var(--p1-color); color:#fff; padding: 12px; font-family:'Orbitron'; font-size:1.2rem; width: 110px; text-align:center; border-radius: 10px; margin: 12px 0 14px; outline:none; }
    #cam_select { width: min(520px, 84vw); max-width: 520px; margin-bottom: 16px; background:#222; color:#fff; border:none; padding:12px; border-radius:10px; font-family:'Orbitron'; }
    .btn-action { padding: 14px 28px; border-radius: 999px; border:none; background: linear-gradient(45deg, var(--p1-color), var(--p2-color)); color:#fff; font-family:'Orbitron'; cursor:pointer; font-weight:bold; font-size: 1.05rem; transition: 0.25s; }
    .btn-action:hover { transform: scale(1.05); box-shadow: 0 0 18px var(--p1-color); }

    /* Countdown UI responsive */
    #countdown-ui {
      position: fixed; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: clamp(4.2rem, 18vw, 10rem);
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 30px var(--p1-color), 0 0 60px var(--p2-color);
      z-index: 200;
      display: none;
      pointer-events: none;
    }

    /* HP tweaks */
    @media (max-width: 520px){
      .score-box { padding: 8px 12px; min-width: 100px; border-radius: 16px; }
      .hud { justify-content: space-between; }
      #p1-score, #p2-score { font-size: 2.1rem !important; }
      #win-goal { font-size: 1.2rem !important; }
    }
  </style>
</head>

<body>
  <canvas id="output_canvas"></canvas>

  <div id="countdown-ui">3</div>

  <div id="start-menu" class="overlay">
    <div class="glass-panel">
      <h1>Finger Explosion</h1>
      <p style="color:#aaa;">SET WINNING SCORE</p>
      <input type="number" id="goal-input" value="10">
      <br>
      <select id="cam_select"></select>
      <br>
      <button class="btn-action" onclick="startGame()">ENTER ARENA</button>
      <p style="color:#777; font-size: .85rem; margin-top: 14px;">
        Tips HP: buka pakai Chrome/Safari dan izinkan kamera.
      </p>
    </div>
  </div>

  <div id="winner-display" class="overlay">
    <div class="glass-panel">
      <h1 id="winner-name">PLAYER WINS!</h1>
      <button class="btn-action" onclick="location.reload()">REMATCH</button>
    </div>
  </div>

  <div class="hud" style="opacity: 0;">
    <div class="score-box p1-ui">
      <div>PLAYER 1</div>
      <div id="p1-score" style="font-size: 2.5rem;">0</div>
    </div>

    <div style="text-align: center; min-width: 92px;">
      <div style="color:#aaa;">GOAL</div>
      <div id="win-goal" style="font-size: 1.5rem;">10</div>
    </div>

    <div class="score-box p2-ui">
      <div>PLAYER 2</div>
      <div id="p2-score" style="font-size: 2.5rem;">0</div>
    </div>
  </div>

  <video id="input_video" style="display:none" playsinline></video>

<script>
  let scores = { p1: 0, p2: 0 }, winScore = 10;
  let isRunning = false;
  let gameActive = false;

  let hands, camera, canvasCtx, canvasElement;
  let targets = [];
  let particles = [];
  let trailHistory = { p1: [], p2: [] };

  let smoothPos = {
    p1: { x: 0, y: 0, active: false },
    p2: { x: 0, y: 0, active: false }
  };

  // ========= MOBILE PERF AUTO =========
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const SMOOTH_FACTOR = isMobile ? 0.30 : 0.25;
  const MAX_PARTICLES = isMobile ? 120 : 260;
  const MAX_TRAIL = isMobile ? 10 : 15;
  const EXPLOSION_COUNT = isMobile ? 10 : 15;
  const SHADOW_ON = !isMobile; // matikan shadow berat di hp

  function lerp(a, b, t){ return (1 - t) * a + t * b; }

  // SFX
  const sfxSlice = new Audio('assets/slice.mp3');
  const sfxStart = new Audio('assets/game-start.mp3');
  const sfxOver = new Audio('assets/game-over.mp3');

  function playSfx(audio){
    const sound = audio.cloneNode();
    sound.volume = 0.5;
    sound.play().catch(()=>{});
  }

  // ========= CANVAS RESPONSIVE (retina + aspect-fit) =========
  // game coordinate uses "base" 1280x720 then scaled to screen
  const BASE_W = 1280, BASE_H = 720;
  let scale = 1, offX = 0, offY = 0;

  function resizeCanvas(){
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    // DPR cap biar gak berat di HP
    const dpr = Math.min(window.devicePixelRatio || 1, isMobile ? 1.5 : 2);

    canvasElement.width = Math.floor(vw * dpr);
    canvasElement.height = Math.floor(vh * dpr);
    canvasCtx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels

    // Fit BASE into viewport (cover) to match object-fit:cover
    const s = Math.max(vw / BASE_W, vh / BASE_H);
    scale = s;
    offX = (vw - BASE_W * s) / 2;
    offY = (vh - BASE_H * s) / 2;
  }

  // Convert normalized mediapipe (0..1) => screen coords aligned with cover & mirror
  function mpToScreen(nx, ny){
    // canvas is mirrored in CSS, so x is flipped visually.
    // We MUST flip x mapping: x_screen = (1 - nx)
    const x = ((1 - nx) * BASE_W) * scale + offX;
    const y = (ny * BASE_H) * scale + offY;
    return { x, y };
  }

  // screen => base normalized side decision (kiri/kanan di layar)
  function isLeftSide(screenX){
    const center = window.innerWidth / 2;
    return screenX < center;
  }

  // ========= GAME FX =========
  function createExplosion(x, y, color){
    // particle cap
    if (particles.length > MAX_PARTICLES) particles.splice(0, particles.length - MAX_PARTICLES);

    for(let i=0;i<EXPLOSION_COUNT;i++){
      particles.push({
        x, y,
        vx: (Math.random()-0.5) * (isMobile ? 10 : 15),
        vy: (Math.random()-0.5) * (isMobile ? 10 : 15),
        life: 1.0, color,
        size: Math.random() * (isMobile ? 4 : 5) + 2
      });
    }
  }

  function updateParticles(){
    for(let i=particles.length-1;i>=0;i--){
      const p = particles[i];
      p.x += p.vx; p.y += p.vy; p.life -= 0.035;
      if(p.life <= 0) particles.splice(i, 1);
      else{
        canvasCtx.beginPath();
        canvasCtx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        canvasCtx.fillStyle = p.color;
        canvasCtx.globalAlpha = p.life;
        canvasCtx.fill();
      }
    }
    canvasCtx.globalAlpha = 1.0;
  }

  // ========= TARGET =========
  function createTarget(side){
    // side: 0 => P1 (kanan di normalized karena canvas mirror), 1 => P2 (kiri)
    // tapi kita sekarang pakai "layar" sebagai patokan:
    // P1 = kiri layar, P2 = kanan layar
    // Jadi lebih simpel: buat target di "kiri" untuk P1, "kanan" untuk P2
    const isP1 = (side === 0);

    const minX = isP1 ? 0.06 : 0.56;
    const maxX = isP1 ? 0.44 : 0.94;

    return {
      // store base normalized in BASE coordinates (0..1)
      baseX: Math.random() * (maxX - minX) + minX,
      baseY: Math.random() * 0.60 + 0.20,
      side: side, // 0=p1,1=p2
      r: isMobile ? 26 : 35,
      color: isP1 ? '#00d2ff' : '#ff007f',
      phase: Math.random() * 10,
      speed: 0.02 + Math.random() * 0.02,
      active: true
    };
  }

  function init(){
    canvasElement = document.getElementById('output_canvas');
    canvasCtx = canvasElement.getContext('2d', { alpha:false, desynchronized:true });

    window.addEventListener('resize', resizeCanvas, { passive:true });
    resizeCanvas();

    hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: isMobile ? 0 : 1,         // lebih ringan di HP
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    navigator.mediaDevices.enumerateDevices().then(devices => {
      devices.filter(d => d.kind === 'videoinput').forEach(d => {
        $('#cam_select').append(`<option value="${d.deviceId}">${d.label || 'Camera'}</option>`);
      });
    });
  }

  function startGame(){
    winScore = parseInt($('#goal-input').val()) || 10;
    $('#win-goal').text(winScore);

    targets = []; particles = [];
    scores = { p1:0, p2:0 };
    $('#p1-score').text(0);
    $('#p2-score').text(0);

    $('#start-menu').hide();
    $('.hud').css('opacity', '1');

    // Kamera + playsinline untuk iOS
    camera = new Camera(document.getElementById('input_video'), {
      onFrame: async () => { if(isRunning) await hands.send({ image: document.getElementById('input_video') }); },
      width: BASE_W, height: BASE_H,
      deviceId: $('#cam_select').val()
    });

    camera.start();
    isRunning = true;

    // Countdown
    playSfx(sfxStart);
    let count = 3;
    const cdUi = $('#countdown-ui');
    cdUi.show().text(count);

    const timer = setInterval(() => {
      count--;
      if(count > 0) cdUi.text(count);
      else if(count === 0) cdUi.text("GO!");
      else {
        clearInterval(timer);
        cdUi.fadeOut(150);

        // Spawn targets (lebih sedikit di HP biar smooth)
        const spawnN = isMobile ? Math.min(winScore, 8) : winScore;
        for(let i=0; i<spawnN; i++){
          targets.push(createTarget(0)); // P1 side
          targets.push(createTarget(1)); // P2 side
        }
        gameActive = true;
      }
    }, 1000);
  }

  function onResults(results){
    // Resize just in case orientation change
    // (resizeCanvas is cheap; can be throttled but OK)
    resizeCanvas();

    canvasCtx.save();
    canvasCtx.clearRect(0, 0, window.innerWidth, window.innerHeight);

    // Draw camera background as COVER (match object-fit:cover)
    // We draw results.image into BASE rect then scale+offset
    canvasCtx.translate(offX, offY);
    canvasCtx.scale(scale, scale);
    canvasCtx.drawImage(results.image, 0, 0, BASE_W, BASE_H);
    canvasCtx.restore();

    updateParticles();

    let detectedP1=false, detectedP2=false;

    if(results.multiHandLandmarks){
      results.multiHandLandmarks.forEach(landmarks => {
        // Index tip normalized
        const tip = landmarks[8];

        // Convert to screen coords aligned with mirror+cover
        const raw = mpToScreen(tip.x, tip.y);

        // P1 = kiri layar, P2 = kanan layar (lebih intuitive)
        const isP1 = isLeftSide(raw.x);
        const pKey = isP1 ? 'p1' : 'p2';
        const neon = isP1 ? '#00d2ff' : '#ff007f';
        if(isP1) detectedP1=true; else detectedP2=true;

        if(!smoothPos[pKey].active){
          smoothPos[pKey].x = raw.x;
          smoothPos[pKey].y = raw.y;
          smoothPos[pKey].active = true;
        } else {
          smoothPos[pKey].x = lerp(smoothPos[pKey].x, raw.x, SMOOTH_FACTOR);
          smoothPos[pKey].y = lerp(smoothPos[pKey].y, raw.y, SMOOTH_FACTOR);
        }

        const fx = smoothPos[pKey].x;
        const fy = smoothPos[pKey].y;

        // Trail (limit for perf)
        trailHistory[pKey].push({ x: fx, y: fy });
        if(trailHistory[pKey].length > MAX_TRAIL) trailHistory[pKey].shift();

        if(trailHistory[pKey].length > 2){
          canvasCtx.beginPath();
          canvasCtx.lineWidth = isMobile ? 9 : 12;
          canvasCtx.lineCap = 'round';
          canvasCtx.strokeStyle = neon;
          if(SHADOW_ON){
            canvasCtx.shadowBlur = 14;
            canvasCtx.shadowColor = neon;
          } else canvasCtx.shadowBlur = 0;

          for(let i=0; i<trailHistory[pKey].length-1; i++){
            canvasCtx.globalAlpha = i / trailHistory[pKey].length;
            canvasCtx.moveTo(trailHistory[pKey][i].x, trailHistory[pKey][i].y);
            canvasCtx.lineTo(trailHistory[pKey][i+1].x, trailHistory[pKey][i+1].y);
          }
          canvasCtx.stroke();
          canvasCtx.globalAlpha = 1.0;
          canvasCtx.shadowBlur = 0;
        }

        // Cursor dot
        canvasCtx.beginPath();
        canvasCtx.arc(fx, fy, isMobile ? 12 : 15, 0, Math.PI*2);
        canvasCtx.fillStyle="#fff";
        if(SHADOW_ON){
          canvasCtx.shadowBlur = 18;
          canvasCtx.shadowColor = neon;
        }
        canvasCtx.fill();
        canvasCtx.shadowBlur = 0;

        // Hit test
        if(gameActive){
          for(const t of targets){
            if(!t.active) continue;

            // target position in BASE then scaled
            const tx = (t.baseX + Math.sin(t.phase) * 0.10) * BASE_W * scale + offX;
            const ty = (t.baseY + Math.cos(t.phase) * 0.10) * BASE_H * scale + offY;
            const dist = Math.hypot(fx - tx, fy - ty);

            if(dist < (t.r * scale) + (isMobile ? 18 : 20)){
              // only score if correct side
              const correct = (t.side === 0 && isP1) || (t.side === 1 && !isP1);
              if(correct){
                createExplosion(tx, ty, t.color);
                if(t.side === 0){ scores.p1++; $('#p1-score').text(scores.p1); }
                else { scores.p2++; $('#p2-score').text(scores.p2); }
                playSfx(sfxSlice);
                t.active=false;
                checkWin();
              }
            }
          }
        }
      });
    }

    if(!detectedP1){ smoothPos.p1.active=false; trailHistory.p1=[]; }
    if(!detectedP2){ smoothPos.p2.active=false; trailHistory.p2=[]; }

    // Draw targets
    if(gameActive){
      for(const t of targets){
        if(!t.active) continue;
        t.phase += t.speed;

        const tx = (t.baseX + Math.sin(t.phase) * 0.10) * BASE_W * scale + offX;
        const ty = (t.baseY + Math.cos(t.phase) * 0.10) * BASE_H * scale + offY;

        canvasCtx.beginPath();
        canvasCtx.arc(tx, ty, t.r * scale, 0, Math.PI*2);
        canvasCtx.fillStyle = t.color;
        if(SHADOW_ON){
          canvasCtx.shadowBlur = 22;
          canvasCtx.shadowColor = t.color;
        }
        canvasCtx.fill();
        canvasCtx.shadowBlur = 0;

        canvasCtx.strokeStyle="#fff";
        canvasCtx.lineWidth = 2;
        canvasCtx.stroke();
      }
    }
  }

  function checkWin(){
    if((scores.p1 >= winScore || scores.p2 >= winScore) && gameActive){
      gameActive=false;
      playSfx(sfxOver);
      const winner = scores.p1 >= winScore ? "PLAYER 1" : "PLAYER 2";
      const winColor = scores.p1 >= winScore ? '#00d2ff' : '#ff007f';
      $('#winner-name').text(winner + " WINS!").css('color', winColor);
      $('#winner-display').fadeIn(300).css('display','flex');
    }
  }

  init();
</script>
</body>
</html>